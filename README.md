The idea: _value level_ resolving. You get a strongly typed AST of the query (from a schema-specific AST generated by the `refine_schema` macro), you return a weakly typed response, which gets coerced to the required response shape before being sent.

* Fully asynchronous

What you get: more or less a query AST. The grammar of that AST is defined by your `.gql`schema.

You have to construct a corresponding `json::Value` by yourself.

## Example

Your graphql schema:

```graphql
type Toppings {
  name: String!
  vegan: Boolean
}

type Pizza {
  name: String!
  toppings: [Topping!]!
}

type Query {
  pizzas(name: String): [Pizza!]!
  pizzeriaOpen: Boolean
}
```

Your query:

```
Query {
    pizzas(name: "funghi") {
        name
        toppings: {
            name
            vegan
        }
    }
}
```

```rust
enum QueryField {
    Pizzas
}

struct Query {
    fields: Vec<QueryField>
}
```

How the query you receive would be expressed in Rust with the enums generated by the `#[derive(SomethingCompletelyDifferent)]` macro:

```rust
vec![
    Query::Pizzas {
        name: "funghi".to_string(),
        selection: vec![
            Pizza::Name,
            Pizza::Toppings {
                selection: vec![
                    Topping::Name,
                    Topping::Vegan,
                ]
            }
        ]
    },
]
```

You can see the tree is built with plain Rust enums and `Vec`s. The resolvers can be very simple functions that match on the requested fields.

`tokio-gql` provides convenience functions, macros and methods on the requested fields to make it easier to work with the query tree.

### Pruning

Having to care about which fields to return exactly in a statically typed language like Rust would be cumbersome. While you do have to care specifically about fields that have arguments and are probably going to trigger database or network requests, for "plain" fields, it is simpler to set the whole object on the response builder.

tokio-gql will perform validation and make sure the shape of the response matches the shape of the request. It is by default quite lenient (i.e. it will return null in non-set nullable fields) but can be configured to be stricter.

[See the documentation for more details](/dev/null)

### What about type-safety?

`tokio-gql` does not check at compile time that your response has the correct shape. However:

* You do get a strongly typed request that is easy to work with
* Unit tests can easily catch faulty resolvers (see the [How to test this](#how-to-test-this) section)
* [Pruning](#pruning) ensures that either the response will have the same shape as the request, or the server will return an error

## How to test this

## Error handling

Still has to be figured out. We do want a custom error type for resolvers. There may be more than one error type. We do want localized and global error-handling. Currently investigating how other implementations do it, like [Sangria](http://sangria-graphql.org/learn/#error-handling).

## Supported query directives

The two query directives required by the spec are implemented.

* `@include`: see http://graphql.org/learn/queries/#directives
* `@skip`: see http://graphql.org/learn/queries/#directives

In addition, `@deprecated`.

TODO: inject supported directives as definitions inside the schema string constant in the generated code.

## Features

* Schema and query languages
  * [ ] Object types
  * [ ] Enum types
  * [ ] Input types
  * [ ] Interfaces
  * [ ] Extensions
  * [ ] Query fragments
  * [ ] Union types
  * [ ] Custom scalars (aliases)
  * [ ] Directives
    * [ ] @deprecated
    * [ ] Custom directive-based resolvers (like Sangria http://graphql.org/learn/queries/#directives)
* Server features
  * [ ] Subscriptions
  * [ ] Deferred resolution (like Sangria and dataloader)
  * [ ] Middlewares (like Sangria)
    * For the field resolution callbacks, we could put them in the response builder.
  * [ ] Query reducers (like Sangria)
  * [ ] Query complexity analysis (like Sangria)
  * [ ] Schema stitching (like Apollo)
  * [ ] 0-config graphiql integration
  * [ ] 0-config graphql-playground integration

## Other: authentication

In the same query by ensuring the auth mutation is handled first (like Sangria, but better).
